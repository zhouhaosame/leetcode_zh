def sum_new(*nums):
    print(nums)
    #如果sum_new调用的时候不加*，那么这里的nums是({1, 2, 3, 4},)
    #怎么得到的呢？
    #对于集合{1,2,3,4},*nums=nums1,可得{1,2,3,4}=*nums,因为*代表解开，得到一系列的
    #参数，而({1, 2, 3, 4},)解开之后就是{1,2,3,4}。所以函数
    #里面的nums是({1, 2, 3, 4},)
    #如果加*呢
    #*nums=*nums1。那么*nums1=1 2 3 4(这样表示一组参数)
    #至于为什么nums变成了列表。虽然*（1，2，3，4）={1，2，3，4}
    #因为这是*的性质，不管是集合，列表还是元祖，通过*传递之后，
    #都变成了元祖
nums1=set([1,2,3,4])
nums2=[1,2,3,4]
nums3=(1,2,3,4)
nums4="1234"#('1', '2', '3', '4')
sum_new(*nums1)
sum_new(*nums2)
sum_new(*nums3)
sum_new(*nums4)
sum_new(1234)#在sum_new中print(1234,),就是相当于把1234变成了元祖
"""很明显，字符串，元祖，列表，集合，经过*传递之后都变成了元祖"""
nums4={"a":2,"b":4,"c":6}
sum_new(*nums4)#('b', 'c', 'a'),得到无序的key。
#sum_new(**nums4)，在python3中字典前加两个**已经不用了

"""以上所说的都是*（解压）一个单一的列表，或者字符串，但是如果解压混合的呢"""
a=[1,2,3]
b=[4,5,6]
c=[7,8,9]
zip_a_c=zip(a,c)
print(zip_a_c)#<zip object at 0x000001BD87B4B848>,返回的是一个对象
zip_a_c=list(zip(a,c))
print(zip_a_c)#[(1, 7), (2, 8), (3, 9)]
print(*zip_a_c)#(1, 7) (2, 8) (3, 9)。一组参数，注意，没有逗号间隔。
print(list(zip(*zip_a_c)))#[(1, 2, 3), (7, 8, 9)]。相当于给zip先解压，再压缩，就得到了它的转置矩阵
#再补充一下
print(*[[1,2],[3,4]])#[1,2] [3,4]，说明只是拆开而已，里面的并不会改变
A=[[1,2,3],[4,5,6],[7,8,9]]
A_n=list(zip(*A))
print(A_n)#[(1, 4, 7), (2, 5, 8), (3, 6, 9)]，zip那边自动的将一行变成了元祖
A=[
  [1,2,3],
  [4,5,6],
  [7,8,9]
]
print(A[::])#[[1, 2, 3], [4, 5, 6], [7, 8, 9]],没有改变
print(A[::-1])#[[7, 8, 9], [4, 5, 6], [1, 2, 3]],
"""这里要说明一下，[::-1]是将list转置，这里虽然A表示的是一个二维矩阵
但是，并不是说将每一行转置，而是将行作为元素，然后整个list转置"""
A[::] = zip(*A[::-1])#这个函数的功能是顺时针旋转90度
print(A)#[(7, 4, 1), (8, 5, 2), (9, 6, 3)]
"""上述的代码实现了，矩阵的顺时针90度旋转---先变成转置矩阵，然后将每一行逆序。
但是代码并不是按照这个思路来的，他是先把矩阵反转（最后一行变成第一行那种旋转），然后再转至"""
print(list(zip((1,),(2,))))#[(1,2)]
print(list(zip([1,2,3])))#[(1,), (2,), (3,)]


