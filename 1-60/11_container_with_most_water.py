"""思路一：暴力双重循环（时间复杂度为O(n^2)），其中明显有一些的比较是多余的"""
"""思路二：双指针
减少循环的核心思路是省去没有必要的遍历，并且确保所需的答案一定能被遍历到
假设现在有一个容器，则容器的盛水量取决于容器的底和容器较短的那条高
则我们可以从最大的底长入手，即当容器的底等于数组的长度时，则容器的盛水量为较短边的长乘底
可见 只有较短边会对盛水量造成影响，因此移动较短边的指针，并比较当前盛水量和当前最大盛水量。直至左右指针相遇。
主要的困惑在于如何移动双指针才能保证最大的盛水量被遍历到
假设有左指针left和右指针right，且left指向的值小于right的值，假如我们将右指针左移，则右指针左移后的值和左指针指向的值相比有三种情况
1、右指针指向的值大于左指针
这种情况下，容器的高取决于左指针，但是底变短了，所以容器盛水量一定变小
2、右指针指向的值等于左指针
这种情况下，容器的高取决于左指针，但是底变短了，所以容器盛水量一定变小
3、右指针指向的值小于左指针
这种情况下，容器的高取决于右指针，但是右指针小于左指针，且底也变短了，所以容量盛水量一定变小了

综上所述，容器高度较大的一侧的移动（向未遍历方向的移动）只会造成容器盛水量减小
所以应当移动高度较小一侧的指针，并继续遍历，直至两指针相遇。
更严谨的证明！！！！

之前证明的只是在左指针（右指针不变同理，就是一个动，一个定。之所以这样是因为，在双重暴力法中找到的所有可能，都能在
一个定，一个动的便利方法中找到，不管是左边定还是右边定。最后遍历的可能性是一样的，从趋势上看是两边向中间汇合。
所以我们只要证明在左右指针向中间靠近的过程中，会遍历到最大容量的情况就可以了。）不改变的情况下，
左移右指针只会造成容器的容量减小（左<右）。

以下补充一个简单的反证法证明算法的合理性
当前的算法为：使用两个指针分别指向数组的头和尾。指向的值较小的那个指针移动，即左指针右移，右指针左移。当左右指针相遇时，指针停住。
我们令容量最大时的指针为p_left和p_right。指针相遇共有三种情况：1、都在p_left左边，2、在p_left和p_right中间，3、
都在p_right右边
假设：这个过程中并没有遍历到容量最大的情况（即第二种可能就不考虑了）
对于第三种情况，我们可以假设遍历时左指针先到达p_left，但是当左指针为p_left时，右指针还没有经过p_right，它在p_right_1。
要让他们在指针p_right右边汇合，说明下一步左指针右移，也就是说p_left的高度<p_right_1。这样由于p_left和p_right_1
之间的宽度更大，所以他们的容积才是最大的，与题设矛盾。同理，第一种也是这样
因此该算法的遍历一定经过了最大的盛水量的情况

综上所述，左右指针以矮的移动向中间汇合时，一定经过最大容量。

"""
def maxArea(height):
    i,j=0,len(height)-1
    maxarea=0
    while(i<j):
        if height[i]<height[j]:
            s=(j-i)*height[i]
            i+=1
        else:
            s=(j-i)*height[j]
            j-=1
        if s > maxarea:maxarea= s
    return maxarea
height=[1,8,6,2,5,4,8,3,7]
height=[1,2]
print(maxArea(height))

